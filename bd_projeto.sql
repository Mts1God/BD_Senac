-- ==========================
-- 1) Criação de Tabelas
-- ==========================

CREATE TABLE convenio (
    id_convenio      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nome             VARCHAR2(150) NOT NULL,
    tipo_convenio    VARCHAR2(50)
);

CREATE TABLE paciente (
    id_paciente      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nome             VARCHAR2(150) NOT NULL,
    cpf              VARCHAR2(14) NOT NULL UNIQUE,
    data_nascimento  DATE,
    telefone         VARCHAR2(20),
    endereco         VARCHAR2(300),
    id_convenio      NUMBER,
    CONSTRAINT fk_paciente_convenio FOREIGN KEY (id_convenio)
        REFERENCES convenio(id_convenio)
);

-- Profissional (médicos, enfermeiros, técnicos)
CREATE TABLE profissional (
    id_profissional NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nome            VARCHAR2(150) NOT NULL,
    cargo           VARCHAR2(50),
    registro_profissional VARCHAR2(60),
    especialidade   VARCHAR2(100)
);

-- Setor (Enfermaria, UTI, Emergência...)
CREATE TABLE setor (
    id_setor NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nome     VARCHAR2(150) NOT NULL,
    tipo     VARCHAR2(50),
    andar    VARCHAR2(20)
);

-- Leitos
CREATE TABLE leitos (
    id_leito      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    numero_leito  VARCHAR2(20) NOT NULL,
    tipo_leito    VARCHAR2(60),
    status        VARCHAR2(20) DEFAULT 'DISPONIVEL' NOT NULL,
    id_setor      NUMBER NOT NULL,

    CONSTRAINT fk_leito_setor FOREIGN KEY (id_setor)
        REFERENCES setor(id_setor),

    CONSTRAINT ck_leito_status CHECK (status IN ('OCUPADO','DISPONIVEL','MANUTENCAO'))
);

-- Atendimento (registro de entrada/consulta/alta)
CREATE TABLE atendimento (
    id_atendimento   NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    id_paciente      NUMBER NOT NULL,
    id_setor         NUMBER NOT NULL,
    id_leito         NUMBER,
    data_atendimento DATE NOT NULL,
    hora_atendimento TIMESTAMP,
    diagnostico      CLOB,

    CONSTRAINT fk_atend_paciente FOREIGN KEY (id_paciente)
        REFERENCES paciente(id_paciente),

    CONSTRAINT fk_atend_setor FOREIGN KEY (id_setor)
        REFERENCES setor(id_setor),

    CONSTRAINT fk_atend_leito FOREIGN KEY (id_leito)
        REFERENCES leitos(id_leito)
);

-- Ligação atendimento <-> profissional
CREATE TABLE atendimento_profissional (
    id_atendimento NUMBER NOT NULL,
    id_profissional NUMBER NOT NULL,
    funcao_no_atendimento VARCHAR2(100),

    CONSTRAINT pk_atendimento_profissional PRIMARY KEY (id_atendimento, id_profissional),

    CONSTRAINT fk_ap_atendimento FOREIGN KEY (id_atendimento)
        REFERENCES atendimento(id_atendimento),

    CONSTRAINT fk_ap_profissional FOREIGN KEY (id_profissional)
        REFERENCES profissional(id_profissional)
);

-- Procedimentos (ex: cirurgia, exame, consulta)
CREATE TABLE procedimento (
    id_procedimento NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    descricao       VARCHAR2(200) NOT NULL,
    tipo            VARCHAR2(50),
    valor           NUMBER(12,2) CHECK (valor >= 0)
);

-- Itens de procedimento realizados durante atendimento
CREATE TABLE atendimento_procedimento (
    id_atendimento  NUMBER NOT NULL,
    id_procedimento NUMBER NOT NULL,
    quantidade      NUMBER DEFAULT 1 CHECK (quantidade > 0),
    valor           NUMBER(12,2),
    observacao      VARCHAR2(300),

    CONSTRAINT pk_atendimento_procedimento PRIMARY KEY (id_atendimento, id_procedimento),

    CONSTRAINT fk_atp_atendimento FOREIGN KEY (id_atendimento)
        REFERENCES atendimento(id_atendimento),

    CONSTRAINT fk_atp_procedimento FOREIGN KEY (id_procedimento)
        REFERENCES procedimento(id_procedimento)
);

-- Faturamento (nota/fatura por atendimento)
CREATE TABLE faturamento (
    id_faturamento NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    id_atendimento NUMBER NOT NULL,
    data_faturamento DATE DEFAULT SYSDATE,
    valor_total      NUMBER(14,2),
    status           VARCHAR2(20),

    CONSTRAINT fk_faturamento_atendimento FOREIGN KEY (id_atendimento)
        REFERENCES atendimento(id_atendimento)
);

-- Itens do faturamento (para compor valor_total)
CREATE TABLE faturamento_procedimento (
    id_faturamento  NUMBER NOT NULL,
    id_procedimento NUMBER NOT NULL,
    quantidade      NUMBER DEFAULT 1 CHECK (quantidade > 0),
    valor_unitario  NUMBER(12,2) CHECK (valor_unitario >= 0),

    CONSTRAINT pk_faturamento_procedimento PRIMARY KEY (id_faturamento, id_procedimento),

    CONSTRAINT fk_fp_faturamento FOREIGN KEY (id_faturamento)
        REFERENCES faturamento(id_faturamento),

    CONSTRAINT fk_fp_procedimento FOREIGN KEY (id_procedimento)
        REFERENCES procedimento(id_procedimento)
);

-- Histórico de alterações em atendimento
CREATE TABLE atendimento_historico (
    id_hist NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    id_atendimento NUMBER NOT NULL,
    campo_alterado VARCHAR2(50),
    valor_antigo VARCHAR2(4000),
    valor_novo VARCHAR2(4000),
    data_alteracao TIMESTAMP DEFAULT SYSTIMESTAMP
);

COMMIT;

-- ==========================
-- 2) Índices e constraints adicionais
-- ==========================
CREATE INDEX idx_paciente_cpf ON paciente(cpf);
CREATE INDEX idx_leitos_setor ON leitos(id_setor);
CREATE INDEX idx_atendimento_paciente ON atendimento(id_paciente);

-- ==========================
-- 3) Dados iniciais (exemplos)
-- ==========================
INSERT INTO convenio (nome, tipo_convenio) VALUES ('Unimed', 'Plano Empresarial');
INSERT INTO convenio (nome, tipo_convenio) VALUES ('SUS', 'Público');
INSERT INTO convenio (nome, tipo_convenio) VALUES ('Amil', 'Particular');

INSERT INTO setor (nome, tipo, andar) VALUES ('Enfermaria', 'Clínico', '1º Andar');
INSERT INTO setor (nome, tipo, andar) VALUES ('UTI', 'Intensiva', '2º Andar');

INSERT INTO leitos (numero_leito, tipo_leito, status, id_setor) VALUES ('101', 'Enfermaria', 'DISPONIVEL', 1);
INSERT INTO leitos (numero_leito, tipo_leito, status, id_setor) VALUES ('102', 'Enfermaria', 'DISPONIVEL', 1);
INSERT INTO leitos (numero_leito, tipo_leito, status, id_setor) VALUES ('201', 'UTI', 'DISPONIVEL', 2);

COMMIT;

-- ==========================
-- 4) Triggers (registro automático e integridade de leitos)
-- ==========================
-- Trg: ocupar leito após inserção de atendimento (quando houver leito)
CREATE OR REPLACE TRIGGER trg_ocupa_leito
AFTER INSERT ON atendimento
FOR EACH ROW
WHEN (NEW.id_leito IS NOT NULL)
BEGIN
    UPDATE leitos
       SET status = 'OCUPADO'
     WHERE id_leito = :NEW.id_leito;
END;
/

-- Trg: atualizar status de leitos quando mudar id_leito no atendimento
CREATE OR REPLACE TRIGGER trg_atualiza_leito
AFTER UPDATE OF id_leito ON atendimento
FOR EACH ROW
BEGIN
    -- libera o leito antigo (se existia)
    IF :OLD.id_leito IS NOT NULL THEN
        UPDATE leitos
           SET status = 'DISPONIVEL'
         WHERE id_leito = :OLD.id_leito;
    END IF;

    -- ocupa o novo leito (se informado)
    IF :NEW.id_leito IS NOT NULL THEN
        UPDATE leitos
           SET status = 'OCUPADO'
         WHERE id_leito = :NEW.id_leito;
    END IF;
END;
/

-- Trg: liberar leito quando atendimento for excluído
CREATE OR REPLACE TRIGGER trg_libera_leito
AFTER DELETE ON atendimento
FOR EACH ROW
WHEN (OLD.id_leito IS NOT NULL)
BEGIN
    UPDATE leitos
       SET status = 'DISPONIVEL'
     WHERE id_leito = :OLD.id_leito;
END;
/
-- Trg: definir status padrão em leitos (antes de insert/update)
CREATE OR REPLACE TRIGGER trg_status_leito_default
BEFORE INSERT OR UPDATE ON leitos
FOR EACH ROW
BEGIN
    IF :NEW.status IS NULL THEN
        :NEW.status := 'DISPONIVEL';
    END IF;
END;
/
-- Trg: evitar dupla ocupação simples (verificação básica)
-- OBS: lógica pode variar conforme regras de negócio (reservas, períodos)
CREATE OR REPLACE TRIGGER trg_evitar_dupla_ocupacao
BEFORE UPDATE OF status ON leitos
FOR EACH ROW
WHEN (NEW.status = 'OCUPADO')
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM atendimento
    WHERE id_leito = :OLD.id_leito
      AND id_leito IS NOT NULL
      AND TRUNC(data_atendimento) = TRUNC(SYSDATE);

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20050, 'Leito já está ocupado para o dia atual.');
    END IF;
END;
/
-- Trg: log simples de alterações em atendimento -> tabela historico
CREATE OR REPLACE TRIGGER trg_hist_atendimento
AFTER UPDATE ON atendimento
FOR EACH ROW
BEGIN
    -- Histórico da troca de setor
    IF NVL(:OLD.id_setor, -1) <> NVL(:NEW.id_setor, -1) THEN
        INSERT INTO atendimento_historico (id_atendimento, campo_alterado, valor_antigo, valor_novo)
        VALUES (:OLD.id_atendimento, 'id_setor', TO_CHAR(:OLD.id_setor), TO_CHAR(:NEW.id_setor));
    END IF;

    -- Histórico da troca de leito
    IF NVL(:OLD.id_leito, -1) <> NVL(:NEW.id_leito, -1) THEN
        INSERT INTO atendimento_historico (id_atendimento, campo_alterado, valor_antigo, valor_novo)
        VALUES (:OLD.id_atendimento, 'id_leito', TO_CHAR(:OLD.id_leito), TO_CHAR(:NEW.id_leito));
    END IF;

    -- Histórico do diagnóstico
    IF NVL(:OLD.diagnostico, '##NULL##') <> NVL(:NEW.diagnostico, '##NULL##') THEN
        INSERT INTO atendimento_historico (id_atendimento, campo_alterado, valor_antigo, valor_novo)
        VALUES (:OLD.id_atendimento, 'diagnostico', SUBSTR(:OLD.diagnostico,1,4000), SUBSTR(:NEW.diagnostico,1,4000));
    END IF;

    -- Histórico da data do atendimento
    IF NVL(TO_CHAR(:OLD.data_atendimento,'YYYYMMDD'), '00000000') <> NVL(TO_CHAR(:NEW.data_atendimento,'YYYYMMDD'), '00000000') THEN
        INSERT INTO atendimento_historico (id_atendimento, campo_alterado, valor_antigo, valor_novo)
        VALUES (:OLD.id_atendimento, 'data_atendimento', TO_CHAR(:OLD.data_atendimento), TO_CHAR(:NEW.data_atendimento));
    END IF;
END;
/
-- Trg: recalcula valor_total do faturamento ao inserir/atualizar itens
CREATE OR REPLACE TRIGGER trg_calc_faturamento
AFTER INSERT OR UPDATE ON faturamento_procedimento
FOR EACH ROW
BEGIN
    UPDATE faturamento f
       SET valor_total = (
            SELECT SUM(quantidade * valor_unitario)
              FROM faturamento_procedimento
             WHERE id_faturamento = f.id_faturamento
       )
     WHERE f.id_faturamento = :NEW.id_faturamento;
END;
/
COMMIT;

-- ==========================
-- 5) Funções e Procedures (estilo do professor)
-- ==========================
-- Função: retorna idade do paciente
CREATE OR REPLACE FUNCTION fn_idade_paciente (p_id_paciente NUMBER)
RETURN NUMBER
IS
    v_nasc DATE;
BEGIN
    SELECT data_nascimento INTO v_nasc
    FROM paciente
    WHERE id_paciente = p_id_paciente;

    RETURN TRUNC(MONTHS_BETWEEN(SYSDATE, v_nasc) / 12);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
END;
/
-- Função: verifica status do leito (retorna texto claro)
CREATE OR REPLACE FUNCTION fn_leito_disponivel (p_id_leito NUMBER)
RETURN VARCHAR2
IS
    v_status leitos.status%TYPE;
BEGIN
    SELECT status INTO v_status FROM leitos WHERE id_leito = p_id_leito;
    RETURN NVL(v_status, 'INDEFINIDO');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'INEXISTENTE';
    WHEN OTHERS THEN
        RETURN 'ERRO: ' || SUBSTR(SQLERRM,1,100);
END;
/
-- Procedure: cadastrar paciente (verifica CPF antes)
CREATE OR REPLACE PROCEDURE cadastrar_paciente (
    p_nome            IN paciente.nome%TYPE,
    p_cpf             IN paciente.cpf%TYPE,
    p_data_nasc       IN paciente.data_nascimento%TYPE,
    p_telefone        IN paciente.telefone%TYPE,
    p_endereco        IN paciente.endereco%TYPE,
    p_id_convenio     IN paciente.id_convenio%TYPE DEFAULT NULL
)
IS
    v_existe NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_existe FROM paciente WHERE cpf = p_cpf;
    IF v_existe > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'CPF já cadastrado.');
    END IF;

    INSERT INTO paciente (nome, cpf, data_nascimento, telefone, endereco, id_convenio)
    VALUES (p_nome, p_cpf, p_data_nasc, p_telefone, p_endereco, p_id_convenio);

    COMMIT;
END;
/
-- Procedure: agendar atendimento (faz insert e ocupa leito via trigger)
CREATE OR REPLACE PROCEDURE agendar_atendimento (
    p_id_paciente IN NUMBER,
    p_id_setor IN NUMBER,
    p_id_leito IN NUMBER DEFAULT NULL,
    p_diagnostico IN CLOB DEFAULT NULL
)
IS
BEGIN
    INSERT INTO atendimento (id_paciente, id_setor, id_leito, data_atendimento, hora_atendimento, diagnostico)
    VALUES (p_id_paciente, p_id_setor, p_id_leito, SYSDATE, SYSTIMESTAMP, p_diagnostico);

    COMMIT;
END;
/
-- Procedure: liberar leito (útil ao dar alta manual)
CREATE OR REPLACE PROCEDURE liberar_leito (p_id_leito IN NUMBER)
IS
BEGIN
    UPDATE leitos SET status = 'DISPONIVEL' WHERE id_leito = p_id_leito;
    COMMIT;
END;
/
-- Procedure: cadastrar procedimento (ex.: incluir tabela de preços)
CREATE OR REPLACE PROCEDURE cadastrar_procedimento (
    p_descricao IN procedimento.descricao%TYPE,
    p_tipo IN procedimento.tipo%TYPE,
    p_valor IN procedimento.valor%TYPE
)
IS
BEGIN
    INSERT INTO procedimento (descricao, tipo, valor)
    VALUES (p_descricao, p_tipo, p_valor);
    COMMIT;
END;
/
-- Procedure de exemplo: inserir item de faturamento e recalcular (transação)
CREATE OR REPLACE PROCEDURE adicionar_item_faturamento (
    p_id_faturamento IN NUMBER,
    p_id_procedimento IN NUMBER,
    p_quantidade IN NUMBER,
    p_valor_unitario IN NUMBER
)
IS
BEGIN
    -- Checagens básicas
    IF p_quantidade <= 0 OR p_valor_unitario < 0 THEN
        RAISE_APPLICATION_ERROR(-20010, 'Quantidade/valor inválido.');
    END IF;

    INSERT INTO faturamento_procedimento (id_faturamento, id_procedimento, quantidade, valor_unitario)
    VALUES (p_id_faturamento, p_id_procedimento, p_quantidade, p_valor_unitario);

    -- Trigger trg_calc_faturamento atualiza valor_total
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/
COMMIT;

-- ==========================
-- 6) Views (resumos para atendimento e faturamento)
-- ==========================
CREATE OR REPLACE VIEW vw_resumo_atendimento AS
SELECT 
    a.id_atendimento,
    p.nome AS paciente,
    p.cpf,
    s.nome AS setor,
    l.numero_leito,
    a.data_atendimento,
    a.hora_atendimento,
    SUBSTR(a.diagnostico,1,4000) AS diagnostico
FROM atendimento a
LEFT JOIN paciente p    ON p.id_paciente = a.id_paciente
LEFT JOIN setor s       ON s.id_setor = a.id_setor
LEFT JOIN leitos l      ON l.id_leito = a.id_leito;

CREATE OR REPLACE VIEW vw_faturamento_completo AS
SELECT
    f.id_faturamento,
    a.id_atendimento,
    p.nome AS paciente,
    f.valor_total,
    f.status,
    fp.id_procedimento,
    pr.descricao AS procedimento,
    fp.quantidade,
    fp.valor_unitario,
    (fp.quantidade * fp.valor_unitario) AS subtotal
FROM faturamento f
JOIN atendimento a ON a.id_atendimento = f.id_atendimento
JOIN paciente p ON p.id_paciente = a.id_paciente
JOIN faturamento_procedimento fp ON fp.id_faturamento = f.id_faturamento
JOIN procedimento pr ON pr.id_procedimento = fp.id_procedimento;

CREATE OR REPLACE VIEW vw_pacientes_convenio AS
SELECT 
    p.id_paciente,
    p.nome,
    p.cpf,
    c.nome AS convenio,
    c.tipo_convenio
FROM paciente p
LEFT JOIN convenio c ON c.id_convenio = p.id_convenio;

CREATE OR REPLACE VIEW vw_leitos_status AS
SELECT 
    l.id_leito,
    l.numero_leito,
    l.tipo_leito,
    l.status,
    s.nome AS setor
FROM leitos l
JOIN setor s ON s.id_setor = l.id_setor;

COMMIT;

-- ==========================
-- 7) Pacote (package) exemplificando agrupamento de funções/procs
-- ==========================
CREATE OR REPLACE PACKAGE pkg_hospital AS
    -- Funções
    FUNCTION fn_idade_paciente(p_id_paciente NUMBER) RETURN NUMBER;
    FUNCTION fn_leito_disponivel(p_id_leito NUMBER) RETURN VARCHAR2;

    -- Procedures
    PROCEDURE cadastrar_paciente(
        p_nome        IN VARCHAR2,
        p_cpf         IN VARCHAR2,
        p_data_nasc   IN DATE,
        p_telefone    IN VARCHAR2,
        p_endereco    IN VARCHAR2,
        p_id_convenio IN NUMBER DEFAULT NULL
    );

    PROCEDURE agendar_atendimento(
        p_id_paciente IN NUMBER,
        p_id_setor IN NUMBER,
        p_id_leito IN NUMBER DEFAULT NULL,
        p_diagnostico IN CLOB DEFAULT NULL
    );

    PROCEDURE liberar_leito(p_id_leito IN NUMBER);
END pkg_hospital;
/
CREATE OR REPLACE PACKAGE BODY pkg_hospital AS
    FUNCTION fn_idade_paciente(p_id_paciente NUMBER) RETURN NUMBER IS
        v_nasc DATE;
    BEGIN
        SELECT data_nascimento INTO v_nasc FROM paciente WHERE id_paciente = p_id_paciente;
        RETURN TRUNC(MONTHS_BETWEEN(SYSDATE, v_nasc) / 12);
    EXCEPTION WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    END fn_idade_paciente;

    FUNCTION fn_leito_disponivel(p_id_leito NUMBER) RETURN VARCHAR2 IS
        v_status VARCHAR2(20);
    BEGIN
        SELECT status INTO v_status FROM leitos WHERE id_leito = p_id_leito;
        RETURN v_status;
    EXCEPTION WHEN NO_DATA_FOUND THEN
        RETURN 'INEXISTENTE';
    END fn_leito_disponivel;

    PROCEDURE cadastrar_paciente(
        p_nome        IN VARCHAR2,
        p_cpf         IN VARCHAR2,
        p_data_nasc   IN DATE,
        p_telefone    IN VARCHAR2,
        p_endereco    IN VARCHAR2,
        p_id_convenio IN NUMBER DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO paciente (nome, cpf, data_nascimento, telefone, endereco, id_convenio)
        VALUES (p_nome, p_cpf, p_data_nasc, p_telefone, p_endereco, p_id_convenio);
        COMMIT;
    END cadastrar_paciente;

    PROCEDURE agendar_atendimento(
        p_id_paciente IN NUMBER,
        p_id_setor IN NUMBER,
        p_id_leito IN NUMBER DEFAULT NULL,
        p_diagnostico IN CLOB DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO atendimento (id_paciente, id_setor, id_leito, data_atendimento, hora_atendimento, diagnostico)
        VALUES (p_id_paciente, p_id_setor, p_id_leito, SYSDATE, SYSTIMESTAMP, p_diagnostico);
        COMMIT;
    END agendar_atendimento;

    PROCEDURE liberar_leito(p_id_leito IN NUMBER) IS
    BEGIN
        UPDATE leitos SET status = 'DISPONIVEL' WHERE id_leito = p_id_leito;
        COMMIT;
    END liberar_leito;
END pkg_hospital;
/
COMMIT;

-- ==========================
-- 8) Exemplos de uso e testes (transações + exemplos DBMS_OUTPUT)
-- ==========================
SET SERVEROUTPUT ON;

-- Inserir pacientes de teste
BEGIN
    pkg_hospital.cadastrar_paciente('João Silva', '123.456.789-00', DATE '1990-05-10', '11999999999', 'Rua X, 123', 1);
    pkg_hospital.cadastrar_paciente('Maria Fernanda Alves', '321.654.987-00', DATE '1988-03-21', '11987541236', 'Av. Paulista, 1500', 1);
    pkg_hospital.cadastrar_paciente('Carlos H. Souza', '555.123.789-44', DATE '1975-11-09', '11999887766', 'Rua das Flores, 89', 2);
EXCEPTION WHEN OTHERS THEN
    NULL; -- evitar falha em múltiplos inserts durante desenvolvimento
END;
/
-- Agendar um atendimento (ex.: ocupa leito via trigger)
BEGIN
    pkg_hospital.agendar_atendimento(1, 1, 1, 'Dor abdominal');
END;
/
-- Consultas de exemplo
-- SELECT * FROM vw_resumo_atendimento;
-- SELECT * FROM vw_leitos_status;

-- ==========================
-- 10) Backup, manutenção e observações
-- ==========================
-- Observação: implementações de backup dependem do DBA/infra (RMAN, Data Pump)
-- Sugestão (dev): gerar export lógico via Data Pump (expdp) periodicamente.
-- Manutenção: criar jobs para limpeza de histórico antigo e rebuild de índices.

-- Exemplo de limpeza de histórico (manter 365 dias)
-- DELETE FROM atendimento_historico WHERE data_alteracao < SYSTIMESTAMP - 365;

COMMIT;

